数组:在内存空间中分配的一段连续空间，用来存放相同数据类型的元素。
分析:如果是在函数内部分配的一个动态数组，这个数组空间从栈区分配。
	 什么是连续？不同的数据之间相差的字节大小就是数据类型的大小
	 一定相同数据类型
	 
栈区的特点:动态分配空间(自动申请，自动释放――使用方便)，栈区空间小，容易造成越界。

如何定义数组:存储类型 数据类型 数组名[数组大小];  

数组下标:一定是从0开始
假设int a[5];其中一个下标:a[3],这个a[3]是变量还是常量？下标表示法是变量

初始化:
1、循环使用下标初始化
2、定义数组并且同时初始化:
	a、全部初始化
	b、部分初始化
	
一维数组的数组名:是一个地址常量，这个地址常量代表了整个数组空间。

int a[5];   
a &a[0] &a  地址大小是相同的
a +1 &a[0] + 1 跳过一个数组元素     &a + 1 跳过整个数组

冒泡排序:
假设有一个数组: int a[5] = {12,6,78,3,9};
假设从大到小排序:不知道谁是最大值谁是最小值，从数组的第一个元素开始，相邻的元素进行比较
第一次先找到所有数据中最小值放到数组的最后面:12 和 6比较 如果12小于6，交换位置
											 6 和 78比较，6 < 78,交换位置  12 78 6 3 9
											 6 和 3比较，6 > 3,不需要交换  12 78 6 3 9
											 3 和9 比较，3 < 9，交换位置   12 78 6 9 3

第二次找到剩下的4个数据(12 78 6 9)中最小值。
1、12和78比较 12<78 交换数据   78 12 6 9
2、12和6比较  12 > 6 不交换数据 78 12 6 9
3、6和9比较  6 < 9  交换数据    78 12 9 6  找到最小值6
没必要做这一步4、6和3比较  6 > 3 不需要交换 

第三次比较找到78 12 9 中的最小值

冒泡排序需要使用两层循环:内层循环控制了每找一个最小值，比较的次数
					     外层循环控制需要找几个最小值。


简单选择排序:
int a[5] = {12,6,78,3,9};
从大到小排序:
1、假设第一个元素为最大值。
	int max = a[0];
	int index = 0;//存放的是当前最大值的数组下标
2、从a[1]开始后续的每个元素和max比较，如果a[1] > max,更新max的值：max = a[1];
									  继续判断a[2] > max, 78 > 12,max = 78,当条件成立时还要更新最大值的下标
									  判断a[3] > max, 3 > 78,max = 78
									  判断a[4] > max,9 > 78,max = 78
3、a[index] 和 a[0]交换   
	到此只能将第一个找到的最大值放到a[0]中。
	
但是还要找第二个最大值放到a[1],第三个最大值放在a[2]中，第四个最大值放在a[3]
4、假设第二个元素为最大值
	int max = a[1];
	int index = 1;
5、从a[2]开始每个元素和max比较
6、a[1]和a[index]交换
后续操作都是在重复执行1、2、3的逻辑

二维数组:在内存中分配的一段连续空间，用来存放相同数据类型的元素。
如果从内存的角度考虑问题，二维数组就是一维或者说是线性的。

如果站在人的思维角度思考问题，必须要掌握行和列的特性。

定义方式:存储类型 数据类型 数组名[行数][列数];
比如:int str[2][3];

下表表示法:int str[2][3] = {
						    str[0][0],str[0][1],str[0][2],
							str[1][0],str[1][1],str[1][2]
						    };
str[0][0],str[0][1],str[0][2],str[1][0],str[1][1],str[1][2]
二维数组以行序优先。

数组名:是一个地址。很多资料直接说明――它是一个行地址。
一个二维数组在人的思想中可以理解为一种特殊的一维数组。
int a[2][3];
你们每个人都是c语言之父，可以自己创造新的类型。有同学：将12个字节规定为一种新类型，被叫做xxx

xxx a[2] = {a[0],a[1]};
a[0],a[1]都替代了3个int类型。a[0]代表了一行
a就是a[0]地址 a + 1是a[1]的地址。
a到a+1相当于跳过一个元素,但是这个所谓的元素是一个一维数组。可以理解为a 到 a + 1相当于跳过了一行。

int a[2] = {a[0],a[1]};
a的地址就是a[0]的地址。
a+1就是元素a[1]的地址。

例子:杨辉三角
1
1  1
1  2  1
1  3  3  1
1  4  6  4  1
1  5  10  10  5  1

作业:有一个整型二维数组，假设a[3][4] = {初始化了值}，求出这个二维数组中所有的最大值，以及最大值对应的下标。
数组内部原有的值不能改变位置。

假设有一个二维数组:int a[3][3]={初始化了值};求出一种数字――在这一行最大在这一列最小
前提:最大值只有一个，最小值也只有一个。







